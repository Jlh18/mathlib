/-
Copyright (c) 2021 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes
-/
import ring_theory.adjoin.basic
import linear_algebra.linear_independent
import ring_theory.mv_polynomial.basic
import data.mv_polynomial.supported
import ring_theory.algebraic
import data.mv_polynomial.equiv
/-!
# Algebraic Independence

This file defines algebraic independence of a family of element of an `R` algebra

## Main definitions

* `algebraic_independent` - `algebraic_independent R v` states the family of vectors `v`
  is algebraically independent over `R`, meaning that the canonical map out of the multivariable
  polynomial ring is injective.

* `algebraic_independent.repr` - The canonical map from the subalgebra generated by an
  algebraic independent family into the polynomial ring.

## References

* [Stacks: Transcendence](https://stacks.math.columbia.edu/tag/030D)

## TODO
Prove that a ring is an algebraic extension of the subalgebra generated by a transcendence basis.

## Tags
transcendence basis, transcendence degree, transcendence

-/
noncomputable theory

open function set subalgebra mv_polynomial algebra
open_locale classical big_operators

universes x u v w

variables {ι : Type*} {ι' : Type*} (R : Type*) {K : Type*}
variables {A : Type*} {A' A'' : Type*} {V : Type u} {V' : Type*}
variables (v : ι → A)
variables [comm_ring R] [comm_ring A] [comm_ring A'] [comm_ring A'']
variables [algebra R A] [algebra R A'] [algebra R A'']
variables {a b : R} {x y : A}

/-- `algebraic_independent R v` states the family of vectors `v`
  is algebraically independent over `R`, meaning that the canonical
  map out of the multivariable polynomial ring is injective. -/
def algebraic_independent : Prop :=
injective (mv_polynomial.aeval v : mv_polynomial ι R →ₐ[R] A)

variables {R} {v}

theorem algebraic_independent_iff_ker_eq_bot : algebraic_independent R v ↔
  (mv_polynomial.aeval v : mv_polynomial ι R →ₐ[R] A).to_ring_hom.ker = ⊥ :=
ring_hom.injective_iff_ker_eq_bot _

theorem algebraic_independent_iff : algebraic_independent R v ↔
  ∀p : mv_polynomial ι R, mv_polynomial.aeval (v : ι → A) p = 0 → p = 0 :=
ring_hom.injective_iff _

theorem algebraic_independent_iff_injective_aeval :
  algebraic_independent R v ↔ injective (mv_polynomial.aeval v : mv_polynomial ι R →ₐ[R] A) :=
iff.rfl

@[simp] lemma algebraic_independent_empty_type_iff [is_empty ι] :
  algebraic_independent R v ↔ injective (algebra_map R A) :=
have aeval v = (algebra.of_id R A).comp (@is_empty_alg_equiv R ι _ _).to_alg_hom,
  by { ext i, exact is_empty.elim' ‹is_empty ι› i },
begin
  rw [algebraic_independent, this,
    ← injective.of_comp_iff' _ (@is_empty_alg_equiv R ι _ _).bijective],
  refl
end

namespace algebraic_independent

variables (hv : algebraic_independent R v)

include hv

lemma algebra_map_injective : injective (algebra_map R A) :=
by simpa [← mv_polynomial.algebra_map_eq, function.comp] using
    (injective.of_comp_iff
      (algebraic_independent_iff_injective_aeval.1 hv) (mv_polynomial.C)).2
    (mv_polynomial.C_injective _ _)

lemma linear_independent : linear_independent R v :=
begin
  rw [linear_independent_iff_injective_total],
  have : finsupp.total ι A R v =
    (mv_polynomial.aeval v).to_linear_map.comp (finsupp.total ι _ R X),
  { ext, simp },
  rw this,
  refine hv.comp _,
  rw [← linear_independent_iff_injective_total],
  exact linear_independent_X _ _
end

protected lemma injective [nontrivial R] : injective v :=
hv.linear_independent.injective

lemma ne_zero [nontrivial R] (i : ι) : v i ≠ 0 :=
hv.linear_independent.ne_zero i

lemma comp (f : ι' → ι) (hf : function.injective f) : algebraic_independent R (v ∘ f) :=
λ p q, by simpa [aeval_rename, (rename_injective f hf).eq_iff] using @hv (rename f p) (rename f q)

lemma coe_range : algebraic_independent R (coe : range v → A) :=
by simpa using hv.comp _ (range_splitting_injective v)

lemma map {f : A →ₐ[R] A'} (hf_inj : set.inj_on f (adjoin R (range v))) :
  algebraic_independent R (f ∘ v) :=
have aeval (f ∘ v) = f.comp (aeval v), by ext; simp,
have h : ∀ x : mv_polynomial ι R, aeval v x ∈ (@aeval R _ _ _ _ (coe : range v → A) _).range,
  { intro x,
    rw [alg_hom.mem_range],
    refine ⟨mv_polynomial.rename (cod_restrict v (range v) (mem_range_self)) x, _⟩,
    simp [function.comp, aeval_rename] },
begin
  intros x y hxy,
  rw [this] at hxy,
  rw [adjoin_eq_range] at hf_inj,
  exact hv (hf_inj (h x) (h y) hxy)
end

lemma map' {f : A →ₐ[R] A'} (hf_inj : injective f) : algebraic_independent R (f ∘ v) :=
hv.map (inj_on_of_injective hf_inj _)

omit hv

lemma of_comp (f : A →ₐ[R] A') (hfv : algebraic_independent R (f ∘ v)) :
  algebraic_independent R v :=
have aeval (f ∘ v) = f.comp (aeval v), by ext; simp,
by rw [algebraic_independent, this] at hfv; exact hfv.of_comp

end algebraic_independent

open algebraic_independent

lemma alg_hom.algebraic_independent_iff (f : A →ₐ[R] A') (hf : injective f) :
  algebraic_independent R (f ∘ v) ↔ algebraic_independent R v :=
⟨λ h, h.of_comp f, λ h, h.map (inj_on_of_injective hf _)⟩

@[nontriviality]
lemma algebraic_independent_of_subsingleton [subsingleton R] : algebraic_independent R v :=
by haveI := @mv_polynomial.unique R ι;
  exact algebraic_independent_iff.2 (λ l hl, subsingleton.elim _ _)

theorem algebraic_independent_equiv (e : ι ≃ ι') {f : ι' → A} :
  algebraic_independent R (f ∘ e) ↔ algebraic_independent R f :=
⟨λ h, function.comp.right_id f ▸ e.self_comp_symm ▸ h.comp _ e.symm.injective,
λ h, h.comp _ e.injective⟩

theorem algebraic_independent_equiv' (e : ι ≃ ι') {f : ι' → A} {g : ι → A} (h : f ∘ e = g) :
  algebraic_independent R g ↔ algebraic_independent R f :=
h ▸ algebraic_independent_equiv e

theorem algebraic_independent_subtype_range {ι} {f : ι → A} (hf : injective f) :
  algebraic_independent R (coe : range f → A) ↔ algebraic_independent R f :=
iff.symm $ algebraic_independent_equiv' (equiv.of_injective f hf) rfl

alias algebraic_independent_subtype_range ↔ algebraic_independent.of_subtype_range _

theorem algebraic_independent_image {ι} {s : set ι} {f : ι → A} (hf : set.inj_on f s) :
  algebraic_independent R (λ x : s, f x) ↔ algebraic_independent R (λ x : f '' s, (x : A)) :=
algebraic_independent_equiv' (equiv.set.image_of_inj_on _ _ hf) rfl

lemma algebraic_independent_adjoin (hs : algebraic_independent R v) :
  @algebraic_independent ι R (adjoin R (range v))
      (λ i : ι, ⟨v i, subset_adjoin (mem_range_self i)⟩) _ _ _ :=
algebraic_independent.of_comp (adjoin R (range v)).val hs

/-- A set of algebraically independent vectors in an algebra `A` over a ring `K` is also
algebraically independent over a subring `R` of `K`.
The implementation uses minimal assumptions about the relationship between `R`, `K` and `A`.
The version where `K` is an `R`-algebra is `algebraic_independent.restrict_scalars_algebras`.
 -/
lemma algebraic_independent.restrict_scalars {K : Type*} [comm_ring K] [algebra R K]
   [algebra K A] [is_scalar_tower R K A]
  (hinj : function.injective (algebra_map R K)) (ai : algebraic_independent K v) :
  algebraic_independent R v :=
have (aeval v : mv_polynomial ι K →ₐ[K] A).to_ring_hom.comp
    (mv_polynomial.map (algebra_map R K)) =
    (aeval v : mv_polynomial ι R →ₐ[R] A).to_ring_hom,
  by { ext; simp [algebra_map_eq_smul_one] },
begin
  show injective (aeval v).to_ring_hom,
  rw [← this],
  exact injective.comp ai (mv_polynomial.map_injective _ hinj)
end

/-- Every finite subset of an algebraically independent set is algebraically independent. -/
lemma algebraic_independent_finset_map_embedding_subtype
  (s : set A) (li : algebraic_independent R (coe : s → A)) (t : finset s) :
  algebraic_independent R (coe : (finset.map (embedding.subtype s) t) → A) :=
begin
  let f : t.map (embedding.subtype s) → s := λ x, ⟨x.1, begin
    obtain ⟨x, h⟩ := x,
    rw [finset.mem_map] at h,
    obtain ⟨a, ha, rfl⟩ := h,
    simp only [subtype.coe_prop, embedding.coe_subtype],
  end⟩,
  convert algebraic_independent.comp li f _,
  rintros ⟨x, hx⟩ ⟨y, hy⟩,
  rw [finset.mem_map] at hx hy,
  obtain ⟨a, ha, rfl⟩ := hx,
  obtain ⟨b, hb, rfl⟩ := hy,
  simp only [imp_self, subtype.mk_eq_mk],
end

/--
If every finite set of algebraically independent element has cardinality at most `n`,
then the same is true for arbitrary sets of algebraically independent elements.
-/
lemma algebraic_independent_bounded_of_finset_algebraic_independent_bounded {n : ℕ}
  (H : ∀ s : finset A, algebraic_independent R (λ i : s, (i : A)) → s.card ≤ n) :
  ∀ s : set A, algebraic_independent R (coe : s → A) → cardinal.mk s ≤ n :=
begin
  intros s li,
  apply cardinal.card_le_of,
  intro t,
  rw ← finset.card_map (embedding.subtype s),
  apply H,
  apply algebraic_independent_finset_map_embedding_subtype _ li,
end

section subtype

lemma algebraic_independent.restrict_of_comp_subtype {s : set ι}
  (hs : algebraic_independent R (v ∘ coe : s → A)) :
  algebraic_independent R (s.restrict v) :=
hs

variables (R A)
lemma algebraic_independent_empty_iff : algebraic_independent R (λ x, x : (∅ : set A) → A) ↔
  injective (algebra_map R A) :=
by simp
variables {R A}

lemma algebraic_independent.mono {t s : set A} (h : t ⊆ s)
  (hv : algebraic_independent R (λ x, x : s → A)) : algebraic_independent R (λ x, x : t → A) :=
by simpa [function.comp] using hv.comp (inclusion h) (inclusion_injective h)

end subtype

theorem algebraic_independent.to_subtype_range {ι} {f : ι → A} (hf : algebraic_independent R f) :
  algebraic_independent R (coe : range f → A) :=
begin
  nontriviality R,
  { rwa algebraic_independent_subtype_range hf.injective }
end

theorem algebraic_independent.to_subtype_range' {ι} {f : ι → A} (hf : algebraic_independent R f)
  {t} (ht : range f = t) :
  algebraic_independent R (coe : t → A) :=
ht ▸ hf.to_subtype_range

theorem algebraic_independent_comp_subtype {s : set ι} :
  algebraic_independent R (v ∘ coe : s → A) ↔
  ∀ p ∈ (mv_polynomial.supported R s), aeval v p = 0 → p = 0 :=
have (aeval (v ∘ coe : s → A) : _ →ₐ[R] _) =
  (aeval v).comp (rename coe), by ext; simp,
have ∀ p : mv_polynomial s R, rename (coe : s → ι) p = 0 ↔ p = 0,
  from (ring_hom.injective_iff' (rename (coe : s → ι) : mv_polynomial s R →ₐ[R] _).to_ring_hom).1
    (rename_injective _ subtype.val_injective),
by simp [algebraic_independent_iff, supported_eq_range_rename, *]

theorem algebraic_independent_subtype {s : set A} :
  algebraic_independent R (λ x, x : s → A) ↔
  ∀ (p : mv_polynomial A R), p ∈ mv_polynomial.supported R s → aeval id p = 0 → p = 0 :=
by apply @algebraic_independent_comp_subtype _ _ _ id

lemma algebraic_independent_of_finite (s : set A)
  (H : ∀ t ⊆ s, finite t → algebraic_independent R (λ x, x : t → A)) :
  algebraic_independent R (λ x, x : s → A) :=
algebraic_independent_subtype.2 $
  λ p hp, algebraic_independent_subtype.1 (H _ (mem_supported.1 hp) (finset.finite_to_set _)) _
    (by simp)

theorem algebraic_independent.image_of_comp {ι ι'} (s : set ι) (f : ι → ι') (g : ι' → A)
  (hs : algebraic_independent R (λ x : s, g (f x))) :
  algebraic_independent R (λ x : f '' s, g x) :=
begin
  nontriviality R,
  have : inj_on f s, from inj_on_iff_injective.2 hs.injective.of_comp,
  exact (algebraic_independent_equiv' (equiv.set.image_of_inj_on f s this) rfl).1 hs
end

theorem algebraic_independent.image {ι} {s : set ι} {f : ι → A}
  (hs : algebraic_independent R (λ x : s, f x)) : algebraic_independent R (λ x : f '' s, (x : A)) :=
by convert algebraic_independent.image_of_comp s f id hs

lemma algebraic_independent_Union_of_directed {η : Type*} [nonempty η]
  {s : η → set A} (hs : directed (⊆) s)
  (h : ∀ i, algebraic_independent R (λ x, x : s i → A)) :
  algebraic_independent R (λ x, x : (⋃ i, s i) → A) :=
begin
  refine algebraic_independent_of_finite (⋃ i, s i) (λ t ht ft, _),
  rcases finite_subset_Union ft ht with ⟨I, fi, hI⟩,
  rcases hs.finset_le fi.to_finset with ⟨i, hi⟩,
  exact (h i).mono (subset.trans hI $ bUnion_subset $
    λ j hj, hi j (fi.mem_to_finset.2 hj))
end

lemma algebraic_independent_sUnion_of_directed {s : set (set A)}
  (hsn : s.nonempty)
  (hs : directed_on (⊆) s)
  (h : ∀ a ∈ s, algebraic_independent R (λ x, x : (a : set A) → A)) :
  algebraic_independent R (λ x, x : (⋃₀ s) → A) :=
by letI : nonempty s := nonempty.to_subtype hsn;
rw sUnion_eq_Union; exact
algebraic_independent_Union_of_directed hs.directed_coe (by simpa using h)

lemma exists_maximal_algebraic_independent
  (s t : set A) (hst : s ⊆ t)
  (hs : algebraic_independent R (coe : s → A)) :
  ∃ u : set A, algebraic_independent R (coe : u → A) ∧ s ⊆ u ∧ u ⊆ t ∧
    ∀ v : set A, algebraic_independent R (coe : v → A) →
      u ⊆ v → v ⊆ t → v = u :=
begin
  rcases zorn.zorn_subset_nonempty
      { u : set A | algebraic_independent R (coe : u → A) ∧ s ⊆ u ∧ u ⊆ t }
    (λ c hc chainc hcn, ⟨⋃₀ c, begin
      refine ⟨⟨algebraic_independent_sUnion_of_directed hcn
        chainc.directed_on
        (λ a ha, (hc ha).1), _, _⟩, _⟩,
      { cases hcn with v hv,
        exact subset_sUnion_of_subset _ v (hc hv).2.1 hv },
      { exact sUnion_subset (λ v hv, (hc hv).2.2) },
      { intros s,
        exact subset_sUnion_of_mem }
    end⟩)
  s ⟨hs, set.subset.refl s, hst⟩ with ⟨u, ⟨huai, hsu, hut⟩, hsu, hv⟩,
  use [u, huai, hsu, hut],
  intros v hvai huv hvt,
  exact hv _ ⟨hvai, trans hsu huv, hvt⟩ huv,
end

section repr
variables (hv : algebraic_independent R v)

/-- Canonical isomorphism between polynomial and the subalgebra generated by
  algebraically independent elements. -/
def algebraic_independent.aeval_equiv (hv : algebraic_independent R v) :
  (mv_polynomial ι R) ≃ₐ[R] algebra.adjoin R (range v) :=
begin
  apply alg_equiv.of_bijective
    (alg_hom.cod_restrict (@aeval R A ι _ _ v _) (algebra.adjoin R (range v)) _),
  swap,
  { intros x,
    rw [adjoin_range_eq_range_aeval],
    exact alg_hom.mem_range_self _ _ },
  { split,
    { exact (alg_hom.injective_cod_restrict _ _ _).2 hv },
    { rintros ⟨x, hx⟩,
      rw [adjoin_range_eq_range_aeval] at hx,
      rcases hx with ⟨y, rfl⟩,
      use y,
      ext,
      simp } }
end

@[simp] lemma algebraic_independent.aeval_equiv_X (hv : algebraic_independent R v) (i : ι) :
  hv.aeval_equiv (X i) = ⟨v i, subset_adjoin (set.mem_range_self _)⟩ :=
subtype.ext (aeval_X v i)

/-- The canonical map from the subalgebra generated by an algebraic independent family
  into the polynomial ring.  -/
def algebraic_independent.repr (hv : algebraic_independent R v) :
  algebra.adjoin R (range v) →ₐ[R] mv_polynomial ι R := hv.aeval_equiv.symm

@[simp] lemma algebraic_independent.aeval_repr (x) : aeval v (hv.repr x) = x :=
subtype.ext_iff.1 (alg_equiv.apply_symm_apply hv.aeval_equiv x)

lemma algebraic_independent.aeval_comp_repr :
  (aeval v).comp hv.repr = subalgebra.val _ :=
alg_hom.ext $ hv.aeval_repr

lemma algebraic_independent.repr_ker :
  (hv.repr : adjoin R (range v) →+* mv_polynomial ι R).ker = ⊥ :=
(ring_hom.injective_iff_ker_eq_bot _).1 (alg_equiv.injective _)

end repr

theorem algebraic_independent.option_iff (hv : algebraic_independent R v) (x : A) :
  (algebraic_independent R (λ o : option ι, o.elim x v)) ↔
    ¬ is_algebraic (adjoin R (set.range v)) x :=
let e : mv_polynomial (option ι) R ≃+* polynomial (adjoin R (set.range v)) :=
  (mv_polynomial.option_equiv_left _ _).to_ring_equiv.trans
    (polynomial.map_equiv hv.aeval_equiv.to_ring_equiv) in
have ring_hom.comp (polynomial.aeval x :
      polynomial (adjoin R (set.range v)) →ₐ[_] A).to_ring_hom
    e.to_ring_hom = (mv_polynomial.aeval (λ o : option ι, o.elim x v)).to_ring_hom,
  begin
    letI : is_scalar_tower R (mv_polynomial ι R) (polynomial (mv_polynomial ι R)) :=
        @polynomial.is_scalar_tower (mv_polynomial ι R) _ R _ _ _ _ _ _ _,
    ext,
    { simp [e, ring_equiv.to_ring_hom_eq_coe, is_scalar_tower.algebra_map_eq R
        (mv_polynomial ι R) (polynomial (mv_polynomial ι R)),
        ← mv_polynomial.algebra_map_eq, ← polynomial.C_eq_algebra_map,
        is_scalar_tower.algebra_map_eq R (adjoin R (set.range v)) A] },
    { intro i,
      cases i;
      simp [ring_equiv.to_ring_hom_eq_coe], refl }
  end,
by erw [algebraic_independent_iff_injective_aeval, is_algebraic_iff_not_injective, not_not,
    ← alg_hom.coe_to_ring_hom, ← alg_hom.to_ring_hom_eq_coe, ← this,
    ring_hom.coe_comp, injective.of_comp_iff' _ e.bijective, alg_hom.to_ring_hom_eq_coe,
    alg_hom.coe_to_ring_hom]

variable (R)
/--
  A family is a transcendence basis if it is a maximal algebraically independent subset.
-/
def is_transcendence_basis (v : ι → A) : Prop :=
algebraic_independent R v ∧
  ∀ (s : set A) (i' : algebraic_independent R (coe : s → A)) (h : range v ≤ s), range v = s

lemma exists_is_transcendence_basis (h : injective (algebra_map R A)) :
  ∃ s : set A, is_transcendence_basis R (coe : s → A) :=
begin
  cases exists_maximal_algebraic_independent (∅ : set A) set.univ
    (set.subset_univ _) ((algebraic_independent_empty_iff R A).2 h) with s hs,
  use [s, hs.1],
  intros t ht hr,
  simp only [subtype.range_coe_subtype, set_of_mem_eq] at *,
  exact eq.symm (hs.2.2.2 t ht hr (set.subset_univ _))
end

variable {R}
lemma algebraic_independent.is_transcendence_basis_iff
  {ι : Type w} {R : Type u} [comm_ring R] [nontrivial R]
  {A : Type v} [comm_ring A] [algebra R A] {v : ι → A} (i : algebraic_independent R v) :
  is_transcendence_basis R v ↔ ∀ (κ : Type v) (w : κ → A) (i' : algebraic_independent R w)
    (j : ι → κ) (h : w ∘ j = v), surjective j :=
begin
  fsplit,
  { rintros p κ w i' j rfl,
    have p := p.2 (range w) i'.coe_range (range_comp_subset_range _ _),
    rw [range_comp, ←@image_univ _ _ w] at p,
    exact range_iff_surjective.mp (image_injective.mpr i'.injective p) },
  { intros p,
    use i,
    intros w i' h,
    specialize p w (coe : w → A) i'
      (λ i, ⟨v i, range_subset_iff.mp h i⟩)
      (by { ext, simp, }),
    have q := congr_arg (λ s, (coe : w → A) '' s) p.range_eq,
    dsimp at q,
    rw [←image_univ, image_image] at q,
    simpa using q, },
end

lemma is_transcendence_basis.is_algebraic [nontrivial R]
  (hv : is_transcendence_basis R v) : is_algebraic (adjoin R (range v)) A :=
begin
  intro x,
  rw [← not_iff_comm.1 (hv.1.option_iff _).symm],
  intro ai,
  have h₁ : range v ⊆ range (λ o : option ι, o.elim x v),
  { rintros x ⟨y, rfl⟩, exact ⟨some y, rfl⟩ },
  have h₂ : range v ≠ range (λ o : option ι, o.elim x v),
  { intro h,
    have : x ∈ range v, { rw h, exact ⟨none, rfl⟩ },
    rcases this with ⟨y, rfl⟩,
    have : some y = none := ai.injective rfl,
    simpa },
  exact h₂ (hv.2 (set.range (λ o : option ι, o.elim x v))
    ((algebraic_independent_subtype_range ai.injective).2 ai) h₁)
end

section field
variables [field K] [algebra K A]

@[simp] lemma algebraic_independent_empty_type [is_empty ι] [nontrivial A] :
  algebraic_independent K v :=
begin
  rw [algebraic_independent_empty_type_iff],
  exact ring_hom.injective _,
end

lemma algebraic_independent_empty [nontrivial A] :
  algebraic_independent K (coe : ((∅ : set A) → A)) :=
algebraic_independent_empty_type

end field
