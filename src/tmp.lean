import analysis.calculus.mean_value
import measure_theory.measure.haar_lebesgue


variables {E : Type*} [normed_group E] [normed_space ‚Ñù E]
          {F : Type*} [normed_group F] [normed_space ‚Ñù F]

open metric set asymptotics
open_locale pointwise topological_space

/-- Consider a map `f` with an invertible derivative `f'` at a point `x`. Then the preimage under
`f` of a small neighborhood `f x + r ‚Ä¢ s` of `f x` resembles the preimage of `r ‚Ä¢ s` under `f'`.
Here we prove that the rescaling of the latter by a fixed factor `t < 1` is contained in the former,
for small enough `r`. -/
lemma eventually_smul_preimage_fderiv_subset_preimage
  {f : E ‚Üí F} {x : E} {f' : E ‚âÉL[‚Ñù] F} (hf : has_fderiv_at f (f' : E ‚ÜíL[‚Ñù] F) x)
  {s : set F} (s_conv : convex ‚Ñù s) (hs : s ‚àà ùìù (0 : F)) (h's : bounded s)
  {t : ‚Ñù} (ht : t ‚àà Ico (0 : ‚Ñù) 1) :
  ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù), {x} + r ‚Ä¢ t ‚Ä¢ f' ‚Åª¬π' (s) ‚äÜ f ‚Åª¬π' ({f x} + r ‚Ä¢ s) :=
begin
  obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ (Œµ : ‚Ñù) (H : 0 < Œµ), t ‚Ä¢ s + closed_ball (0 : F) Œµ ‚äÜ s :=
    s_conv.exists_smul_add_closed_ball_subset hs ht,
  obtain ‚ü®R, Rpos, Rs‚ü© : ‚àÉ R, 0 < R ‚àß f' ‚Åª¬π' s ‚äÜ closed_ball (0 : E) R :=
    (f'.antilipschitz.bounded_preimage h's).subset_ball_lt _ _,
  obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
    ‚àÉ (Œ¥ : ‚Ñù) (H : 0 < Œ¥), closed_ball 0 Œ¥ ‚äÜ {z : E | ‚à•f (x + z) - f x - f' z‚à• ‚â§ (Œµ / R) * ‚à•z‚à•} :=
      nhds_basis_closed_ball.mem_iff.1
        ((has_fderiv_at_iff_is_o_nhds_zero.1 hf).def (div_pos Œµpos Rpos)),
  have : Ioc (0 : ‚Ñù) (Œ¥ / R) ‚àà ùìù[Ioi (0 : ‚Ñù)] 0,
  { apply Ioc_mem_nhds_within_Ioi,
    simp only [div_pos Œ¥pos Rpos, left_mem_Ico] },
  filter_upwards [this],
  rintros r ‚ü®rpos, rle‚ü© y hy,
  obtain ‚ü®z, f'z, rfl‚ü© : ‚àÉ (z : E), f' z ‚àà s ‚àß x + r ‚Ä¢ t ‚Ä¢ z = y,
    by simpa only [mem_smul_set, image_add_left, exists_exists_and_eq_and, mem_preimage,
                   singleton_add, neg_add_eq_sub, eq_sub_iff_add_eq'] using hy, clear hy,
  have z_le : ‚à•z‚à• ‚â§ R, by simpa only [mem_closed_ball, dist_zero_right] using Rs f'z,
  simp only [image_add_left, mem_preimage, singleton_add, neg_add_eq_sub],
  let u := f (x + (r * t) ‚Ä¢ z) - f x - f' ((r * t) ‚Ä¢ z),
  suffices H : (r * t) ‚Ä¢ f' z + u ‚àà r ‚Ä¢ s,
  { convert H, simp only [add_sub_cancel'_right, smul_smul, u, continuous_linear_equiv.map_smul] },
  let v := r ‚Åª¬π ‚Ä¢ u,
  suffices H : t ‚Ä¢ f' z + v ‚àà s,
  { have : (r * t) ‚Ä¢ f' z + u = r ‚Ä¢ (t ‚Ä¢ f' z + v),
      by simp only [smul_smul, mul_inv_cancel rpos.ne', smul_add, one_smul],
    rw this,
    exact smul_mem_smul_set H },
  suffices H : ‚à•u‚à• ‚â§ Œµ * r,
  { apply hŒµ,
    apply set.add_mem_add (smul_mem_smul_set f'z),
    simpa only [norm_smul, real.norm_eq_abs, abs_of_nonneg (inv_nonneg.mpr rpos.le),
      ‚Üê div_eq_inv_mul, div_le_iff rpos, mem_closed_ball, dist_zero_right] using H },
  have I‚ÇÄ : ‚à•(r * t) ‚Ä¢ z‚à• ‚â§ r * R, from calc
    ‚à•(r * t) ‚Ä¢ z‚à• = r * t * ‚à•z‚à• :
      by simp only [norm_smul, real.norm_eq_abs, abs_of_nonneg, mul_nonneg rpos.le ht.left]
    ... ‚â§ r * 1 * R : by apply_rules [mul_le_mul, ht.2.le, ht.1, norm_nonneg, mul_nonneg,
                                      zero_le_one, le_refl, rpos.le]
    ... = r * R : by rw [mul_one],
  have I : ‚à•(r * t) ‚Ä¢ z‚à• ‚â§ Œ¥, from calc
    ‚à•(r * t) ‚Ä¢ z‚à• ‚â§ r * R : I‚ÇÄ
    ... ‚â§ (Œ¥ / R) * R : mul_le_mul_of_nonneg_right rle Rpos.le
    ... = Œ¥ : by field_simp [Rpos.ne'],
  calc ‚à•u‚à• ‚â§ Œµ / R * ‚à•(r * t) ‚Ä¢ z‚à• :
    by { apply hŒ¥, simpa only [mem_closed_ball, dist_zero_right] using I }
  ... ‚â§ Œµ / R * (r * R) : mul_le_mul_of_nonneg_left I‚ÇÄ (div_nonneg Œµpos.le Rpos.le)
  ... = Œµ * r : by { field_simp [Rpos.ne'], ring }
end

@[simp] lemma singleton_add_ball {E : Type*} [normed_group E] (x y : E) (r : ‚Ñù) :
  {x} + ball y r = ball (x + y) r :=
by simp only [preimage_add_ball, image_add_left, singleton_add, sub_neg_eq_add, add_comm y x]

lemma singleton_add_ball_zero {E : Type*} [normed_group E] (x : E) (r : ‚Ñù) :
  {x} + ball 0 r = ball x r :=
by simp


/-- If `u` is a neighborhood of `x`, then for small enough `r`, the closed ball
`closed_ball x r` is contained in `u`. -/
lemma eventually_closed_ball_subset
  {x : E} {u : set E} (hu : u ‚àà ùìù x) :
  ‚àÄ·∂† r in ùìù (0 : ‚Ñù), closed_ball x r ‚äÜ u :=
begin
  obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ (hŒµ : 0 < Œµ), closed_ball x Œµ ‚äÜ u :=
    nhds_basis_closed_ball.mem_iff.1 hu,
  have : Iic Œµ ‚àà ùìù (0 : ‚Ñù) := Iic_mem_nhds Œµpos,
  filter_upwards [this],
  assume r hr,
  exact subset.trans (closed_ball_subset_closed_ball hr) hŒµ,
end

/-- If `s` is a bounded set, then for small enough `r`, the set `{x} + r ‚Ä¢ s` is contained in any
fixed neighborhood of `x`. -/
lemma eventually_singleton_add_smul_subset
  {x : E} {s : set E} (hs : bounded s) {u : set E} (hu : u ‚àà ùìù x) :
  ‚àÄ·∂† r in ùìù (0 : ‚Ñù), {x} + r ‚Ä¢ s ‚äÜ u :=
begin
  obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ (hŒµ : 0 < Œµ), closed_ball x Œµ ‚äÜ u :=
    nhds_basis_closed_ball.mem_iff.1 hu,
  obtain ‚ü®R, Rpos, hR‚ü© : ‚àÉ (R : ‚Ñù), 0 < R ‚àß s ‚äÜ closed_ball 0 R := hs.subset_ball_lt 0 0,
  have : metric.closed_ball (0 : ‚Ñù) (Œµ / R) ‚àà ùìù (0 : ‚Ñù) :=
    closed_ball_mem_nhds _ (div_pos Œµpos Rpos),
  filter_upwards [this],
  assume r hr,
  simp only [image_add_left, singleton_add],
  assume y hy,
  obtain ‚ü®z, zs, hz‚ü© : ‚àÉ (z : E), z ‚àà s ‚àß r ‚Ä¢ z = -x + y, by simpa [mem_smul_set] using hy,
  have I : ‚à•r ‚Ä¢ z‚à• ‚â§ Œµ := calc
    ‚à•r ‚Ä¢ z‚à• = ‚à•r‚à• * ‚à•z‚à• : norm_smul _ _
    ... ‚â§ (Œµ / R) * R :
      mul_le_mul (mem_closed_ball_zero_iff.1 hr)
        (mem_closed_ball_zero_iff.1 (hR zs)) (norm_nonneg _) (div_pos Œµpos Rpos).le
    ... = Œµ : by field_simp [Rpos.ne'],
  have : y = x + r ‚Ä¢ z, by simp only [hz, add_neg_cancel_left],
  apply hŒµ,
  simpa only [this, dist_eq_norm, add_sub_cancel', mem_closed_ball] using I,
end

lemma metric.bounded.smul {E : Type*} [normed_group E] {ùïú : Type*} [normed_field ùïú] [normed_space ùïú E]
  {s : set E} (hs : bounded s) (c : ùïú) :
  bounded (c ‚Ä¢ s) :=
begin
  obtain ‚ü®R, Rpos, hR‚ü© : ‚àÉ (R : ‚Ñù), 0 < R ‚àß s ‚äÜ closed_ball 0 R := hs.subset_ball_lt 0 0,
  refine (bounded_iff_subset_ball 0).2 ‚ü®‚à•c‚à• * R, _‚ü©,
  assume z hz,
  obtain ‚ü®y, ys, rfl‚ü© : ‚àÉ (y : E), y ‚àà s ‚àß c ‚Ä¢ y = z := mem_smul_set.1 hz,
  simp only [mem_closed_ball_zero_iff],
  calc ‚à•c ‚Ä¢ y‚à• = ‚à•c‚à• * ‚à•y‚à• : norm_smul _ _
  ... ‚â§ ‚à•c‚à• * R : mul_le_mul_of_nonneg_left (mem_closed_ball_zero_iff.1 (hR ys)) (norm_nonneg _)
end

lemma linear_map.image_smul_set {E : Type*} [add_comm_group E] {F : Type*} [add_comm_group F]
  {ùïú : Type*} [field ùïú] [module ùïú E] [module ùïú F] (f : E ‚Üí‚Çó[ùïú] F) (c : ùïú) (s : set E) :
  f '' (c ‚Ä¢ s) = c ‚Ä¢ f '' s :=
begin
  apply subset.antisymm,
  { rintros x ‚ü®y, ‚ü®z, zs, rfl‚ü©, rfl‚ü©,
    exact ‚ü®f z, mem_image_of_mem _ zs, (f.map_smul _ _).symm ‚ü© },
  { rintros x ‚ü®y, ‚ü®z, hz, rfl‚ü©, rfl‚ü©,
    exact (mem_image _ _ _).2 ‚ü®c ‚Ä¢ z, smul_mem_smul_set hz, f.map_smul _ _‚ü© }
end

lemma linear_map.preimage_smul_set {E : Type*} [add_comm_group E] {F : Type*} [add_comm_group F]
  {ùïú : Type*} [field ùïú] [module ùïú E] [module ùïú F] (f : E ‚Üí‚Çó[ùïú] F) {c : ùïú} (hc : c ‚â† 0) (s : set F) :
  f ‚Åª¬π' (c ‚Ä¢ s) = c ‚Ä¢ f ‚Åª¬π' s :=
begin
  apply subset.antisymm,
  { rintros x ‚ü®y, ys, hy‚ü©,
    refine ‚ü®c‚Åª¬π ‚Ä¢ x, _, _‚ü©,
    { simp only [‚Üêhy, smul_smul, inv_mul_cancel hc, ys, ring_hom.id_apply, one_smul, mem_preimage,
        linear_map.map_smul‚Çõ‚Çó] },
    { simp only [smul_smul, mul_inv_cancel hc, one_smul] } },
  { rintros x ‚ü®y, hy, rfl‚ü©,
    refine ‚ü®f y, hy, by simp only [ring_hom.id_apply, linear_map.map_smul‚Çõ‚Çó]‚ü© }
end

lemma linear_equiv.preimage_smul_set {E : Type*} [add_comm_group E] {F : Type*} [add_comm_group F]
  {ùïú : Type*} [field ùïú] [module ùïú E] [module ùïú F] (f : E ‚âÉ‚Çó[ùïú] F) (c : ùïú) (s : set F) :
  f ‚Åª¬π' (c ‚Ä¢ s) = c ‚Ä¢ f ‚Åª¬π' s :=
begin
  rcases eq_empty_or_nonempty s with rfl|hs,
  { simp only [preimage_empty, smul_set_empty] },
  rcases eq_or_ne c 0 with rfl|hc,
  { simp only [zero_smul_set hs, zero_smul_set (hs.preimage f.surjective)],
    ext x,
    simp only [linear_equiv.map_eq_zero_iff, mem_preimage, set.mem_zero] },
  { exact linear_map.preimage_smul_set (f : E ‚Üí‚Çó[ùïú] F) hc s }
end

lemma continuous_linear_equiv.preimage_smul_set {E : Type*} [normed_group E] {F : Type*} [normed_group F]
  {ùïú : Type*} [normed_field ùïú] [module ùïú E] [module ùïú F] (f : E ‚âÉL[ùïú] F) (c : ùïú) (s : set F) :
  f ‚Åª¬π' (c ‚Ä¢ s) = c ‚Ä¢ f ‚Åª¬π' s :=
linear_equiv.preimage_smul_set _ c s

lemma continuous_linear_map.image_smul_set {E : Type*} [normed_group E] {F : Type*} [normed_group F]
  {ùïú : Type*} [normed_field ùïú] [module ùïú E] [module ùïú F] (f : E ‚ÜíL[ùïú] F) (c : ùïú) (s : set E) :
  f '' (c ‚Ä¢ s) = c ‚Ä¢ f '' s :=
linear_map.image_smul_set _ c s

lemma set_smul_mem_nhds_zero {E : Type*} [normed_group E] {ùïú : Type*} [normed_field ùïú] [normed_space ùïú E]
  {s : set E} (hs : s ‚àà ùìù (0 : E)) {c : ùïú} (hc : c ‚â† 0) :
  c ‚Ä¢ s ‚àà ùìù (0 : E) :=
begin
  obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ (Œµ : ‚Ñù) (H : 0 < Œµ), ball 0 Œµ ‚äÜ s := metric.mem_nhds_iff.1 hs,
  have : c ‚Ä¢ ball (0 : E) Œµ ‚àà ùìù (0 : E),
  { rw [smul_ball hc, smul_zero],
    exact ball_mem_nhds _ (mul_pos (by simpa using hc) Œµpos) },
  exact filter.mem_of_superset this ((set_smul_subset_set_smul_iff‚ÇÄ hc).2 hŒµ)
end

lemma set_smul_mem_nhds_zero_iff {E : Type*} [normed_group E] {ùïú : Type*} [normed_field ùïú] [normed_space ùïú E]
  (s : set E) {c : ùïú} (hc : c ‚â† 0) :
  c ‚Ä¢ s ‚àà ùìù (0 : E) ‚Üî s ‚àà ùìù(0 : E) :=
begin
  refine ‚ü®Œª h, _, Œª h, set_smul_mem_nhds_zero h hc‚ü©,
  convert set_smul_mem_nhds_zero h (inv_ne_zero hc),
  rw [smul_smul, inv_mul_cancel hc, one_smul],
end


lemma eventually_image_ball_subset_image_ball_fderiv
  {f : E ‚Üí F} {x : E} {f' : E ‚ÜíL[‚Ñù] F} (hf : has_fderiv_at f f' x) {Œµ : ‚Ñù} (Œµpos : 0 < Œµ) :
  ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù), f '' (ball x r) ‚äÜ ball (f x) (Œµ * r) + f' '' (ball 0 r) :=
begin
  obtain ‚ü®R, Rpos, hR‚ü© : ‚àÉ (R : ‚Ñù) (H : R > 0),
    ball x R ‚äÜ {z : E | ‚à•f z - f x - f' (z - x)‚à• ‚â§ Œµ * ‚à•z - x‚à•} :=
      metric.mem_nhds_iff.1 (is_o.def hf Œµpos),
  have : Ioo (0 : ‚Ñù) R ‚àà ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù) := Ioo_mem_nhds_within_Ioi ‚ü®le_rfl, Rpos‚ü©,
  filter_upwards [this],
  rintros r hr y ‚ü®z, hz, rfl‚ü©,
  refine set.mem_add.2 ‚ü®f z - f' (z - x), f' (z - x), _, _, by abel‚ü©,
  { simp only [dist_eq_norm, mem_ball],
    calc ‚à•f z - f' (z - x) - f x‚à•
    = ‚à•f z - f x - f' (z - x)‚à• : by { congr' 1, abel }
    ... ‚â§ Œµ * ‚à•z - x‚à• : hR (ball_subset_ball hr.2.le hz)
    ... < Œµ * r : (mul_lt_mul_left Œµpos).2 (mem_ball_iff_norm.1 hz) },
  { apply mem_image_of_mem,
    simpa only [mem_ball_iff_norm, sub_zero] using hz }
end

lemma eventually_smul_image_ball_subset_image_ball_fderiv
  {f : E ‚Üí F} {x : E} {f' : E ‚ÜíL[‚Ñù] F} (hf : has_fderiv_at f f' x) {Œµ : ‚Ñù} (Œµpos : 0 < Œµ) :
  ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù),
    r‚Åª¬π ‚Ä¢ ({-f x} + f '' (ball x r)) ‚äÜ ball 0 Œµ + f' '' (ball 0 1) :=
begin
  filter_upwards [eventually_image_ball_subset_image_ball_fderiv hf Œµpos, self_mem_nhds_within],
  assume r hr rpos,
  replace rpos : 0 < r := rpos,
  have A : r‚Åª¬π ‚â† 0, by simp only [rpos.ne', inv_eq_zero, ne.def, not_false_iff],
  have B : r‚Åª¬π * (Œµ * r) = Œµ, by field_simp [rpos.ne'],
  calc r‚Åª¬π ‚Ä¢ ({-f x} + f '' ball x r)
  ‚äÜ r‚Åª¬π ‚Ä¢ ({-f x} + (ball (f x) (Œµ * r) + f' '' (ball 0 r))) :
    smul_set_mono (add_subset_add subset.rfl hr)
  ... = ball 0 Œµ + f' '' ball 0 1 : begin
    rw [‚Üê add_assoc, singleton_add_ball, add_left_neg, smul_add_set, ‚Üê f'.image_smul_set,
      smul_ball A, smul_ball A],
    simp only [real.norm_eq_abs, smul_zero, abs_of_nonneg (inv_nonneg.2 rpos.le),
      inv_mul_cancel rpos.ne', B],
  end
end

/-- Consider a map `f` with an invertible derivative `f'` at a point `x`. Then the preimage under
`f` of a small neighborhood `f x + r ‚Ä¢ s` of `f x` resembles the preimage of `r ‚Ä¢ s` under `f'`.
Here we prove that the rescaling of the latter by a fixed factor `t < 1` is contained in the
intersection of the former with an arbitrary neighborhood of `x`, for small enough `r`. -/
lemma eventually_smul_preimage_fderiv_subset_inter_preimage
  {f : E ‚Üí F} {x : E} {f' : E ‚âÉL[‚Ñù] F} (hf : has_fderiv_at f (f' : E ‚ÜíL[‚Ñù] F) x)
  {s : set F} (s_conv : convex ‚Ñù s) (hs : s ‚àà ùìù (0 : F)) (h's : bounded s)
  {t : ‚Ñù} (ht : t ‚àà Ico (0 : ‚Ñù) 1) {u : set E} (hu : u ‚àà ùìù x) :
  ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù), {x} + r ‚Ä¢ t ‚Ä¢ f' ‚Åª¬π' (s) ‚äÜ u ‚à© f ‚Åª¬π' ({f x} + r ‚Ä¢ s) :=
begin
  have A : ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù), {x} + r ‚Ä¢ t ‚Ä¢ f' ‚Åª¬π' (s) ‚äÜ f ‚Åª¬π' ({f x} + r ‚Ä¢ s) :=
    eventually_smul_preimage_fderiv_subset_preimage hf s_conv hs h's ht,
  have B : ‚àÄ·∂† r in ùìù (0 : ‚Ñù), {x} + r ‚Ä¢ t ‚Ä¢ f' ‚Åª¬π' (s) ‚äÜ u :=
    eventually_singleton_add_smul_subset ((f'.antilipschitz.bounded_preimage h's).smul _) hu,
  filter_upwards [A, nhds_within_le_nhds B],
  assume r hr h'r,
  exact subset_inter h'r hr
end

/-- Consider a map `f` with an invertible derivative `f'` at a point `x`. Then the preimage under
`f` of a small neighborhood `f x + r ‚Ä¢ s` of `f x` resembles the preimage of `r ‚Ä¢ s` under `f'`.
Here we prove that the rescaling of the former by a fixed factor `t < 1` is contained in the latter,
for small enough `r`, if `f` is a local homeomorphism. -/
lemma eventually_preimage_smul_subset_preimage_fderiv
  {f : local_homeomorph E F} {x : E} {f' : E ‚âÉL[‚Ñù] F}
  (hx : x ‚àà f.source) (hf : has_fderiv_at f (f' : E ‚ÜíL[‚Ñù] F) x)
  {s : set F} (s_conv : convex ‚Ñù s) (hs : s ‚àà ùìù (0 : F)) (h's : bounded s)
  {t : ‚Ñù} (ht : 1 < t) :
  ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù), f.source ‚à© f ‚Åª¬π' ({f x} + r ‚Ä¢ s) ‚äÜ {x} + r ‚Ä¢ t ‚Ä¢ f' ‚Åª¬π' (s) :=
begin
  have htinv : t‚Åª¬π ‚àà Ico (0 : ‚Ñù) 1 := ‚ü®inv_nonneg.2 (zero_lt_one.trans ht).le, inv_lt_one ht‚ü©,
  have h'f : has_fderiv_at f.symm (f'.symm : F ‚ÜíL[‚Ñù] E) (f x) := f.has_fderiv_at_symm' hx hf,
  let s' := t ‚Ä¢ f' ‚Åª¬π' s,
  have s'_conv : convex ‚Ñù s', by { apply convex.smul, exact s_conv.linear_preimage f' },
  have hs' : s' ‚àà ùìù (0 : E),
  { rw set_smul_mem_nhds_zero_iff _ (zero_lt_one.trans ht).ne',
    apply f'.continuous.continuous_at,
    simpa only [continuous_linear_equiv.map_zero] using hs },
  have h's' : bounded s' := (f'.antilipschitz.bounded_preimage h's).smul _,
  filter_upwards [eventually_smul_preimage_fderiv_subset_preimage h'f s'_conv hs' h's' htinv],
  assume r hr,
  simp only [f'.symm_preimage_preimage, s', hx, local_homeomorph.left_inv, mul_one, smul_smul,
    continuous_linear_equiv.preimage_smul_set, inv_mul_cancel (zero_lt_one.trans ht).ne'] at hr,
  rw [‚Üê smul_smul] at hr,
  calc f.source ‚à© f ‚Åª¬π' ({f x} + r ‚Ä¢ s)
    ‚äÜ f.source ‚à© f ‚Åª¬π' ((f.symm) ‚Åª¬π' ({x} + r ‚Ä¢ t ‚Ä¢ ‚áëf' ‚Åª¬π' s)) :
      inter_subset_inter_right _ (preimage_mono hr)
    ... = f.source ‚à© ({x} + r ‚Ä¢ t ‚Ä¢ ‚áëf' ‚Åª¬π' s) : f.source_inter_preimage_inv_preimage _
    ... ‚äÜ {x} + r ‚Ä¢ t ‚Ä¢ ‚áëf' ‚Åª¬π' s : inter_subset_right _ _
end


.

open filter measure_theory measure_theory.measure finite_dimensional

variables [measurable_space E] [finite_dimensional ‚Ñù E] [borel_space E]
  (Œº : measure E) [is_add_haar_measure Œº]


lemma tendsto_mu_add_ball {s : set E} (hs : is_compact s) :
  tendsto (Œª r, Œº (closed_ball 0 r + s)) (ùìù 0) (ùìù (Œº s)) :=
sorry

lemma tendsto_add_haar_preimage_ball_div_add_haar_ball
  (f : local_homeomorph E E) (g : E ‚ÜíL[‚Ñù] E) (y : E) (y_mem : y ‚àà f.target)
  (h : has_fderiv_at f.symm g y) :
  tendsto (Œª r, Œº (f.source ‚à© f ‚Åª¬π' (closed_ball y r)) / Œº (closed_ball y r)) (ùìù[Ioi (0 : ‚Ñù)] 0)
    (ùìù (ennreal.of_real (abs (linear_map.det (g : E ‚Üí‚Çó[‚Ñù] E))))) :=
begin
  let d := ennreal.of_real (abs (linear_map.det (g : E ‚Üí‚Çó[‚Ñù] E))),
  let x := f.symm y,
  have x_mem : x ‚àà f.source := f.map_target y_mem,
  have L1 : tendsto (Œª Œµ, Œº (closed_ball 0 Œµ + g '' (closed_ball 0 1)))
    (ùìù 0) (ùìù (Œº (g '' (closed_ball 0 1)))),
  { apply tendsto_mu_add_ball,
    exact (proper_space.is_compact_closed_ball _ _).image g.continuous },
  have L2 : tendsto (Œª Œµ, Œº (closed_ball 0 Œµ + g '' (closed_ball 0 1)))
    (ùìù 0) (ùìù (d * Œº (closed_ball 0 1))),
  { convert L1,

  }


end

#exit

  have B : ‚àÄ m, d < m ‚Üí ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù),
      Œº (f.source ‚à© f ‚Åª¬π' (closed_ball y r)) / Œº (closed_ball y r) < m,
  { assume m hm,
    have L : tendsto (Œª (t : ‚Ñù), ennreal.of_real (t ^ finrank ‚Ñù E) * d) (ùìù[Ioi 1] 1)
      (ùìù (ennreal.of_real (1 ^ finrank ‚Ñù E) * d)),
    { apply ennreal.tendsto.mul_const _ (or.inr ennreal.of_real_ne_top),
      apply ennreal.tendsto_of_real (tendsto.pow _ _),
      exact nhds_within_le_nhds, },
    simp only [one_pow, one_mul, ennreal.of_real_one] at L,
    obtain ‚ü®t, tlim, ht‚ü© : ‚àÉ (t : ‚Ñù), ennreal.of_real (t ^ finrank ‚Ñù E) * d < m ‚àß
      1 < t := (((tendsto_order.1 L).2 _ hm).and self_mem_nhds_within).exists,
    have R1 : ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù),
      f.source ‚à© f ‚Åª¬π' (closed_ball y r) = f.symm '' (closed_ball y r),
    { have : ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù), closed_ball y r ‚äÜ f.target,
      { apply nhds_within_le_nhds,
        exact eventually_closed_ball_subset (f.open_target.mem_nhds y_mem) },
      filter_upwards [this],
      assume r hr,
      have : f.is_image (f.source ‚à© f ‚Åª¬π' (closed_ball y r)) (closed_ball y r),
      { apply local_homeomorph.is_image.of_preimage_eq',
        simp only [inter_eq_right_iff_subset.mpr hr, ‚Üêinter_assoc, inter_self] },
      simpa only [inter_eq_right_iff_subset.mpr hr, ‚Üêinter_assoc, inter_self]
        using this.symm_image_eq.symm },
    filter_upwards [R1, self_mem_nhds_within],
    assume r hr1 rpos,
    change 0 < r at rpos,
    rw [hr1, ennreal.div_lt_iff (or.inl (add_haar_closed_ball_pos Œº y rpos).ne')
          (or.inl (add_haar_closed_ball_lt_top Œº y r).ne)],
  }
end

#exit
    have : ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù), Œº (f.source ‚à© f ‚Åª¬π' (closed_ball y r)) ‚â§
      ennreal.of_real (r ^ finrank ‚Ñù E) * ennreal.of_real (t ^ finrank ‚Ñù E)
        * d * Œº (closed_ball 0 1),
     { have : ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù), f.source ‚à© f ‚Åª¬π' ({f x} + r ‚Ä¢ closed_ball 0 1)
        ‚äÜ {x} + r ‚Ä¢ t ‚Ä¢ f' x ‚Åª¬π' (closed_ball 0 1) :=
          eventually_preimage_smul_subset_preimage_fderiv x_mem (h x x_mem)
          (convex_closed_ball _ _) (closed_ball_mem_nhds _ zero_lt_one) bounded_closed_ball ht,
      filter_upwards [this, self_mem_nhds_within],
      assume r hr r_pos,
      replace r_pos : 0 < r := r_pos,
      calc
      Œº (f.source ‚à© f ‚Åª¬π' (closed_ball y r))
      = Œº (f.source ‚à© f ‚Åª¬π' ({f x} + r ‚Ä¢ closed_ball 0 1)) :
        by simp only [y_mem, smul_closed_ball, zero_le_one, real.norm_eq_abs, abs_of_nonneg r_pos.le,
          mul_one, preimage_add_closed_ball, image_add_left, local_homeomorph.right_inv, zero_add,
          singleton_add, smul_zero, sub_neg_eq_add]
      ... ‚â§ Œº ({x} + r ‚Ä¢ t ‚Ä¢ ‚áë(f' x) ‚Åª¬π' closed_ball 0 1) : measure_mono hr
      ... = ennreal.of_real (r ^ finrank ‚Ñù E) * ennreal.of_real (t ^ finrank ‚Ñù E) * d
        * Œº (closed_ball 0 1) : begin
          simp only [abs_of_nonneg, r_pos.le, (zero_lt_one.trans ht).le, mul_assoc, add_haar_smul,
            image_add_left, pow_nonneg, add_haar_preimage_add, singleton_add,
            haar_preimage_continuous_linear_equiv, coe_coe],
          refl,
        end },
    filter_upwards [this, self_mem_nhds_within],
    assume r hr rpos,
    replace rpos : 0 < r := rpos,
    apply lt_of_le_of_lt (ennreal.div_le_of_le_mul _) tlim,
    rw [add_haar_closed_ball' Œº _ rpos.le],
    convert hr using 1,
    ring },
end

#exit


lemma tendsto_add_haar_preimage_ball_div_add_haar_ball
  (f : local_homeomorph E E) (f' : E ‚Üí (E ‚âÉL[‚Ñù] E))
  (h : ‚àÄ x ‚àà f.source, has_fderiv_at f (f' x : E ‚ÜíL[‚Ñù] E) x)
  (y : E) (y_mem : y ‚àà f.target) :
  tendsto (Œª r, Œº (f.source ‚à© f ‚Åª¬π' (closed_ball y r)) / Œº (closed_ball y r)) (ùìù[Ioi (0 : ‚Ñù)] 0)
    (ùìù (ennreal.of_real (abs (linear_map.det ((f' (f.symm y)).symm : E ‚Üí‚Çó[‚Ñù] E))))) :=
begin
  let d := ennreal.of_real (abs (linear_map.det ((f' (f.symm y)).symm : E ‚Üí‚Çó[‚Ñù] E))),
  let x := f.symm y,
  have x_mem : x ‚àà f.source := f.map_target y_mem,
  have A : ‚àÄ l, l < d ‚Üí ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù),
      l < Œº (f.source ‚à© f ‚Åª¬π' (closed_ball y r)) / Œº (closed_ball y r),
  { assume l hl,
    have L : tendsto (Œª (t : ‚Ñù), ennreal.of_real (t ^ finrank ‚Ñù E) * d) (ùìù[Ico 0 1] 1)
      (ùìù (ennreal.of_real (1 ^ finrank ‚Ñù E) * d)),
    { apply ennreal.tendsto.mul_const _ (or.inr ennreal.of_real_ne_top),
      apply ennreal.tendsto_of_real (tendsto.pow _ _),
      exact nhds_within_le_nhds, },
    simp only [one_pow, one_mul, ennreal.of_real_one] at L,
    haveI : (ùìù[Ico (0 : ‚Ñù) 1] 1).ne_bot := right_nhds_within_Ico_ne_bot zero_lt_one,
    obtain ‚ü®t, tlim, ht‚ü© : ‚àÉ (t : ‚Ñù), l < ennreal.of_real (t ^ finrank ‚Ñù E) * d ‚àß
      t ‚àà Ico (0 : ‚Ñù) 1 := (((tendsto_order.1 L).1 _ hl).and self_mem_nhds_within).exists,
    have : ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù),
      ennreal.of_real (r ^ finrank ‚Ñù E) * ennreal.of_real (t ^ finrank ‚Ñù E) * d * Œº (closed_ball 0 1)
        ‚â§ Œº (f.source ‚à© f ‚Åª¬π' (closed_ball y r)),
    { have : ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù), {x} + r ‚Ä¢ t ‚Ä¢ f' x ‚Åª¬π' (closed_ball 0 1)
        ‚äÜ f.source ‚à© f ‚Åª¬π' ({f x} + r ‚Ä¢ closed_ball 0 1) :=
          eventually_smul_preimage_fderiv_subset_inter_preimage (h x x_mem)
            (convex_closed_ball _ _) (closed_ball_mem_nhds _ zero_lt_one) bounded_closed_ball ht
            (f.open_source.mem_nhds x_mem),
      filter_upwards [this, self_mem_nhds_within],
      assume r hr r_pos,
      replace r_pos : 0 < r := r_pos,
      calc
      ennreal.of_real (r ^ finrank ‚Ñù E) * ennreal.of_real (t ^ finrank ‚Ñù E) * d
        * Œº (closed_ball 0 1)
      = Œº ({x} + r ‚Ä¢ t ‚Ä¢ ‚áë(f' x) ‚Åª¬π' closed_ball 0 1) :
        by simp only [abs_of_nonneg, r_pos.le, ht.left, add_haar_smul, image_add_left, pow_nonneg,
          add_haar_preimage_add, singleton_add, mul_assoc, haar_preimage_continuous_linear_equiv]
      ... ‚â§ Œº (f.source ‚à© f ‚Åª¬π' ({f x} + r ‚Ä¢ closed_ball 0 1)) : measure_mono hr
      ... = Œº (f.source ‚à© f ‚Åª¬π' closed_ball y r) :
        by simp only [y_mem, smul_closed_ball, zero_le_one, real.norm_eq_abs, abs_of_nonneg r_pos.le,
          mul_one, preimage_add_closed_ball, image_add_left, local_homeomorph.right_inv, zero_add,
          singleton_add, smul_zero, sub_neg_eq_add] },
    filter_upwards [this, self_mem_nhds_within],
    assume r hr rpos,
    replace rpos : 0 < r := rpos,
    apply tlim.trans_le,
    rw [ennreal.le_div_iff_mul_le (or.inl (add_haar_closed_ball_pos Œº _ rpos).ne')
      (or.inl (add_haar_closed_ball_lt_top Œº _ _).ne), add_haar_closed_ball' Œº _ rpos.le],
    convert hr using 1,
    ring },
  have B : ‚àÄ m, d < m ‚Üí ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù),
      Œº (f.source ‚à© f ‚Åª¬π' (closed_ball y r)) / Œº (closed_ball y r) < m,
  { assume m hm,
    have L : tendsto (Œª (t : ‚Ñù), ennreal.of_real (t ^ finrank ‚Ñù E) * d) (ùìù[Ioi 1] 1)
      (ùìù (ennreal.of_real (1 ^ finrank ‚Ñù E) * d)),
    { apply ennreal.tendsto.mul_const _ (or.inr ennreal.of_real_ne_top),
      apply ennreal.tendsto_of_real (tendsto.pow _ _),
      exact nhds_within_le_nhds, },
    simp only [one_pow, one_mul, ennreal.of_real_one] at L,
    obtain ‚ü®t, tlim, ht‚ü© : ‚àÉ (t : ‚Ñù), ennreal.of_real (t ^ finrank ‚Ñù E) * d < m ‚àß
      1 < t := (((tendsto_order.1 L).2 _ hm).and self_mem_nhds_within).exists,
    have : ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù), Œº (f.source ‚à© f ‚Åª¬π' (closed_ball y r)) ‚â§
      ennreal.of_real (r ^ finrank ‚Ñù E) * ennreal.of_real (t ^ finrank ‚Ñù E)
        * d * Œº (closed_ball 0 1),
     { have : ‚àÄ·∂† r in ùìù[Ioi (0 : ‚Ñù)] (0 : ‚Ñù), f.source ‚à© f ‚Åª¬π' ({f x} + r ‚Ä¢ closed_ball 0 1)
        ‚äÜ {x} + r ‚Ä¢ t ‚Ä¢ f' x ‚Åª¬π' (closed_ball 0 1) :=
          eventually_preimage_smul_subset_preimage_fderiv x_mem (h x x_mem)
          (convex_closed_ball _ _) (closed_ball_mem_nhds _ zero_lt_one) bounded_closed_ball ht,
      filter_upwards [this, self_mem_nhds_within],
      assume r hr r_pos,
      replace r_pos : 0 < r := r_pos,
      calc
      Œº (f.source ‚à© f ‚Åª¬π' (closed_ball y r))
      = Œº (f.source ‚à© f ‚Åª¬π' ({f x} + r ‚Ä¢ closed_ball 0 1)) :
        by simp only [y_mem, smul_closed_ball, zero_le_one, real.norm_eq_abs, abs_of_nonneg r_pos.le,
          mul_one, preimage_add_closed_ball, image_add_left, local_homeomorph.right_inv, zero_add,
          singleton_add, smul_zero, sub_neg_eq_add]
      ... ‚â§ Œº ({x} + r ‚Ä¢ t ‚Ä¢ ‚áë(f' x) ‚Åª¬π' closed_ball 0 1) : measure_mono hr
      ... = ennreal.of_real (r ^ finrank ‚Ñù E) * ennreal.of_real (t ^ finrank ‚Ñù E) * d
        * Œº (closed_ball 0 1) : begin
          simp only [abs_of_nonneg, r_pos.le, (zero_lt_one.trans ht).le, mul_assoc, add_haar_smul,
            image_add_left, pow_nonneg, add_haar_preimage_add, singleton_add,
            haar_preimage_continuous_linear_equiv, coe_coe],
          refl,
        end },
    filter_upwards [this, self_mem_nhds_within],
    assume r hr rpos,
    replace rpos : 0 < r := rpos,
    apply lt_of_le_of_lt (ennreal.div_le_of_le_mul _) tlim,
    rw [add_haar_closed_ball' Œº _ rpos.le],
    convert hr using 1,
    ring },
  exact tendsto_order.2 ‚ü®A, B‚ü©,

end
